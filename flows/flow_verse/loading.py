import os
import re
import sys
import shutil
import inspect
from typing import List, Dict

import colorama
import huggingface_hub

from flows.utils import logging

logger = logging.get_logger(__name__)

default_home = os.path.join(os.path.expanduser("~"), ".cache")
flows_cache_home = os.path.expanduser(os.path.join(default_home, "flows"))
DEFAULT_CACHE_PATH = os.path.join(flows_cache_home, "flow_verse")
DEFAULT_FLOW_MODULE_FOLDER = "flow_modules"
MODULE_ID_FILE_NAME = "FLOW_MODULE_ID"
REVISION_FILE_HEADER = """\
########################################
# auto-generated by flows, DO NOT EDIT #
########################################
"""
DEFAULT_REMOTE_REVISION = "main"

# TODO(yeeef): huggingface username might not be a valid python module name... for example `1f`
def add_to_sys_path(path):
    # Make sure the path is absolute
    absolute_path = os.path.abspath(path)

    # Check if the path is in sys.path
    if absolute_path not in sys.path:
        # If it's not, add it
        sys.path.append(absolute_path)


add_to_sys_path(f"./{DEFAULT_FLOW_MODULE_FOLDER}")

def validate_and_augment_dependency(dependency: Dict[str, str]):
    if "url" not in dependency: # TODO(yeeef): url is not descriptive
        raise ValueError("dependency must have a `url` field")

    if not re.search(r"\w+/\w+", dependency["url"]):
        raise ValueError("dependency url must be in the format of `username/repo_name`(huggingface repo)")

    if "revision" not in dependency:
        dependency["revision"] = DEFAULT_REMOTE_REVISION

    return dependency


def write_or_append_gitignore(local_dir: str, mode: str, content: str):
    gitignore_path = os.path.join(local_dir, ".gitignore")
        
    with open(gitignore_path, mode) as gitignore_f:
        lines = [
            "\n\n\n# auto-generated by flows, all synced modules will be ignored by default\n",
            f"{content}\n"
        ]
        gitignore_f.writelines(lines)


def write_mod_id(local_dir: str, mod_id: str):
    revision_file_path = os.path.join(local_dir, MODULE_ID_FILE_NAME)
    with open(revision_file_path, "w") as revision_f:
        lines = [
            REVISION_FILE_HEADER,
            mod_id,
        ]
        revision_f.writelines(lines)
        revision_f.write("\n")


def read_mod_id(local_dir: str):
    revision_file_path = os.path.join(local_dir, MODULE_ID_FILE_NAME)
    if not os.path.exists(revision_file_path):
        return "INVALID_REVISION"

    with open(revision_file_path, "r") as revision_f:
        lines = revision_f.readlines()
        if len(lines) != 4:
            return None

        if "".join(lines[:3]) != REVISION_FILE_HEADER:
            return None

        return lines[3].strip()

def remove_dir_or_link(sync_dir: str):
    if os.path.isdir(sync_dir):
        shutil.rmtree(sync_dir)
    elif os.path.islink(sync_dir):
        os.remove(sync_dir)
    else:
        raise ValueError(f"Invalid sync_dir: {sync_dir}, it is not a valid directory nor a valid link")

def fetch_remote(repo_id: str, revision: str, flow_mod_id: str, cache_dir: str, local_dir: str):
    sync_dir = os.path.abspath(sync_dir)
    if is_local_sync_dir_valid(sync_dir):
        remove_dir_or_link(sync_dir)

    os.makedirs(os.path.dirname(sync_dir), exist_ok=True)
    huggingface_hub.snapshot_download(repo_id, cache_dir=cache_dir, local_dir=local_dir, revision=revision)
    # write the revision info in the folder
    write_mod_id(local_dir, flow_mod_id)
    # add FLOW_MODULE_ID to .gitignore
    write_or_append_gitignore(local_dir, "a", MODULE_ID_FILE_NAME)

def fetch_local(file_path: str, flow_mod_id: str, sync_dir: str):
    # shutil.copytree(file_path, sync_dir, ignore=shutil.ignore_patterns(".git"), dirs_exist_ok=overwrite)
    sync_dir = os.path.abspath(sync_dir)
    # when fetch_local is triggered, the old dir is always going to be removed
    if is_local_sync_dir_valid(sync_dir):
        remove_dir_or_link(sync_dir)

    os.makedirs(os.path.dirname(sync_dir), exist_ok=True)
    os.symlink(file_path, sync_dir)  # TODO(yeeef): offer another choice to directly make a copy
    # write the revision info in the folder
    write_mod_id(sync_dir, flow_mod_id)
    # add FLOW_MODULE_ID to .gitignore
    write_or_append_gitignore(sync_dir, "a", MODULE_ID_FILE_NAME)


def build_mod_id(repo_id_or_file_path: str, revision: str):
    return f"{repo_id_or_file_path}:{revision}"

def is_local_sync_dir_valid(sync_dir: str):
    return os.path.isdir(sync_dir) or os.path.islink(sync_dir)

def sync_dependency(mod_name: str, revision: str, is_local: bool, caller_module_name: str, overwrite: bool = False) -> str:
    mod_id = build_mod_id(mod_name, revision)

    # ToDo (Martin): Add a check of whether the local copy (when it exists) matches the one suggested bu the depenedency?
    #    Skip everything if it does.
    #    If it doesn't, verbose flag is set and overwrite is not set sent a warning message.
    #    If it doesn't and overwrite is set, ask for confirmation.
    if overwrite:
        logger.warn(f"{colorama.Fore.RED}[{caller_module_name}] {mod_id} will be overwritten, are you sure? (Y/N){colorama.Style.RESET_ALL}")
        user_input = input()
        if user_input != "Y":
            overwrite = False

    sync_dir = None
    if is_local:  # revision is a local path
        module_local_dir = revision

        if not os.path.isdir(module_local_dir):
            raise ValueError(f"{mod_id}'s revision {revision} is not a valid local directory")
        
        sync_dir = os.path.join(os.path.curdir, DEFAULT_FLOW_MODULE_FOLDER, mod_name)
        if not is_local_sync_dir_valid(sync_dir) or overwrite:
            fetch_local(module_local_dir, mod_id, sync_dir)
        elif is_local_sync_dir_valid(sync_dir) and read_mod_id(sync_dir) != mod_id:
            logger.warn(
                f"{colorama.Fore.RED}[{caller_module_name}] {read_mod_id(sync_dir)} already synced, it will be overwritten by new revision {mod_id}, are you sure? (Y/N){colorama.Style.RESET_ALL}")
            user_input = input()
            if user_input == "Y":
                fetch_local(module_local_dir, mod_id, sync_dir)
        else:
            logger.info(f"{mod_id} already synced, skip")

    else:  # huggingface url
        basename = mod_name
        sync_dir = os.path.join(os.path.curdir, DEFAULT_FLOW_MODULE_FOLDER, basename)

        if not is_local_sync_dir_valid(sync_dir) or overwrite:
            # first fetch / overwrite
            logger.info(f"first fetch / overwrite {mod_id}")
            fetch_remote(mod_name, revision, mod_id, DEFAULT_CACHE_PATH, sync_dir)

        elif is_local_sync_dir_valid(sync_dir) and read_mod_id(sync_dir) != mod_id:
            # local dir exists, but revision is not the same, overwrite with new revision
            logger.warn(
                f"{colorama.Fore.RED}[{caller_module_name}] {read_mod_id(sync_dir)} already synced, it will be overwritten by new revision {mod_id}, are you sure? (Y/N){colorama.Style.RESET_ALL}")
            user_input = input()
            if user_input == "Y":
                fetch_remote(mod_name, revision, mod_id, DEFAULT_CACHE_PATH, sync_dir)
        else:
            logger.info(f"{mod_id} already synced, skip")

    return sync_dir


def sync_dependencies(dependencies: List[Dict[str, str]], all_overwrite: bool = False):
    caller_frame = inspect.currentframe().f_back
    caller_module = inspect.getmodule(caller_frame)
    if caller_module is None: # https://github.com/epfl-dlab/flows/issues/50
        caller_module_name = "<interactive>"
    else:
        caller_module_name = caller_module.__name__
    
    logger.info(
        f"{colorama.Fore.GREEN}[{caller_module_name}]{colorama.Style.RESET_ALL} started to sync flow module dependencies...")
    flow_module_dir = os.path.join(os.path.curdir, DEFAULT_FLOW_MODULE_FOLDER)
    if not os.path.exists(flow_module_dir):
        os.mkdir(flow_module_dir)
    elif not os.path.isdir(flow_module_dir):
        raise ValueError(f"flow module folder {flow_module_dir} is not a directory")

    write_or_append_gitignore(flow_module_dir, "w", content="*")

    sync_dirs = []
    for dep in dependencies:
        dep = validate_and_augment_dependency(dep)
        dep_overwrite = dep.get("overwrite", False)
        dep_is_local = False
        url, revision = dep["url"], dep["revision"]

        if os.path.exists(revision): # revision point to a local path
            dep_is_local = True
            revision = os.path.abspath(revision)
            if DEFAULT_FLOW_MODULE_FOLDER in revision:
                raise ValueError(f"syncing a local revision from {DEFAULT_FLOW_MODULE_FOLDER} is not recommended")
        else:
            match = re.search(r"\W", revision)  # ToDo (Martin): This often fails with a cryptic error message
            if match is not None:
                raise ValueError(f"{revision} is identified as remote, as it does not exist locally. But it not a valid remote revision, it contains illegal characters: {match.group(0)}")

        sync_dir = sync_dependency(url, revision, dep_is_local, caller_module_name, all_overwrite or dep_overwrite)
        sync_dirs.append(sync_dir)

    logger.info(f"{colorama.Fore.GREEN}[{caller_module_name}]{colorama.Style.RESET_ALL} finished syncing\n\n")
    return sync_dirs
