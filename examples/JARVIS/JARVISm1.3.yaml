flow:
  _target_: baldwin.JarvisFlowModule.JarvisFlow.instantiate_from_default_config
  max_rounds: 30
  python_file_path: examples/JARVIS/library.py #Relative path from where you're running 
  ### Subflows specification
  subflows_config:
    Controller:
      _target_: baldwin.JarvisFlowModule.JarvisControllerFlow.instantiate_from_default_config
      sys_prompt_pyfile_input_variable_name: python_file
      python_file_path: ${flow.python_file_path}
      commands:
        ask_user:
          description: "Ask the user for feedback on the next command and the plan"
          input_args: ["goal","command","command_args","plan"]
        run_python_code:
          description: "Call a python function which is written in a py file whose contents are in the Python File section"
          input_args: [ "called_function","kwargs" ]
        finish:
          description: "Signal that the objective has been satisfied, and returns the answer to the user."
          input_args: [ "answer" ]


      input_interface_initialized:
        - "observation"
        - "observation_type"

      human_message_prompt_template:
        _target_: flows.prompt_template.JinjaPrompt
        template: |2-
          Here is the response to your last action:
          {{observation}}
          The response was by:
           {{observation_type}}
          If the response was given by the user and he approved it, make sure you rerun the you command you just suggested 
        input_variables:
          - "observation"
          - "observation_type"

      backend:
        api_infos: ???
        model_name:
          openai: gpt-4
          azure: azure/gpt-4
      output_interface:
        - 'thought'
        - 'reasoning'
        - 'plan'
        - 'criticism'
        - 'speak'
        - 'command'
        - 'command_args'

      #######################################################
      # ToDo: Some parts of the prompt don't make sense -- update them
      system_message_prompt_template:
        template: |2-
          You are a smart AI assistant specialized in programming. 
          
          You must work with the user to come up with a proper plan to execute.
          Play to your strengths as an LLM and pursue simple strategies with no legal complications.
          If you have completed all your tasks, make sure to use the "finish" command.
          The user will always give you feedback before you get to run code. 
          If the user approves, you must rerun the command you just suggested
          You must really take in consideration what the user give you as feedback.

          Constraints:
          1. ~4000 word limit for short term memory. Your short term memory is short, so immediately save important information to files
          2. If you are unsure how you previously did something or want to recall past events, thinking about similar events will help you remember
          3. If the user dissapproves, you must imperitavely come up with a solution and reask for his advice
          4. If the user approve your next command, you can rerun the command but ask for feedback in the next step
          5. If the user approves of your whole plan, go ahead and run directly the whole plan. 
          6. Exclusively use functions defined in available functions

          Available Functions:
          {{commands}}

          Python File:
          {{python_file}}

          Resources:
          1. A python file defined in Available functions for execution
          2. Long Term memory management.
          3. GPT powered Agents for delegation of simple tasks.

          Performance Evaluation:
          1. Continuously review and analyze your actions to ensure you are performing to the best of your abilities.
          2. Constructively self-criticize your big-picture behavior constantly.
          3. Reflect on past decisions and strategies to refine your approach.
          4. Every command has a cost, so be smart and efficient. Aim to complete tasks in the least number of steps.
          5. Always Take into account the feedback you get. 
          6. If the user approve your next command, you can rerun the command but ask for feedback in the next step
          7. If the user approves of your whole plan, go ahead and run directly the whole plan. 
          You should absolutely only respond in JSON format as described below
          Response Format:
          {
          "thought": "thought",
          "reasoning": "reasoning",
          "plan": "- short bulleted\n- list that conveys\n- long-term plan",
          "criticism": "constructive self-criticism",
          "speak": "thoughts summary to say to user",
          "command": "the python function you would like to call",
          "command_args": {
              "arg name": "value"
              }
          }
          Ensure your responses can be parsed by Python json.loads
        input_variables: ["commands", "${flow.subflows_config.Controller.sys_prompt_pyfile_input_variable_name}" ]

    Executor:
      _target_: flows.base_flows.BranchingFlow.instantiate_from_default_config
      subflows_config:
        run_python_code:
          _target_: baldwin.PyFileInterpreterFlowModule.PyFileInterpreterAtomicFlow.instantiate_from_default_config
          path_to_py_file: ${flow.python_file_path}

        ask_user:
          _target_: aiflows.HumanStandardInputFlowModule.HumanStandardInputFlow.instantiate_from_default_config
          request_multi_line_input_flag: False
          query_message_prompt_template:
            template: |2-
              Please provide feedback on the last step. To quit type: "q".
              
              Relevant information:
              == Goal == 
              {{goal}}
              
              == Command ==
              {{command}}
              
              == Args
              {{command_args}}
              
              == Plan
              {{plan}}
            input_variables:
              - "goal"
              - "command"
              - "command_args"
              - "plan"
          input_interface_initialized:
            - "goal"
            - "command"
            - "command_args"
            - "plan"


  topology:
    - goal: "Select the next action and prepare the input for the executor."
      input_interface:
        _target_: flows.interfaces.KeyInterface
        keys_to_rename:
          branch_output_data: observation
        additional_transformations:
          - _target_: flows.data_transformations.KeyMatchInput
      flow: Controller
      output_interface:
        _target_: ControllerExecutorFlow.detect_finish_or_continue
      reset: false

    - goal: "Execute the action specified by the Controller."
      input_interface:
        _target_: flows.interfaces.KeyInterface
        keys_to_rename:
          command: branch
          command_args: branch_input_data
        keys_to_select: ["branch", "branch_input_data"]  
      flow: Executor
      output_interface:
        _target_: JarvisFlow.output_of_executor
        additional_transformations:
          - _target_: flows.data_transformations.KeySelect
            keys_to_select: ["observation","observation_type"]
      reset: false